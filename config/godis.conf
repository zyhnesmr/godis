# Godis configuration file

################################## NETWORK #####################################

# By default, if no "bind" configuration directive is specified, Godis listens
# for connections from all the network interfaces available on the server.
# It is possible to listen to just one or multiple selected interfaces using
# the "bind" configuration directive, followed by one or more IP addresses.
bind 0.0.0.0

# Accept connections on the specified port, default is 6379.
port 6379

# Close the connection after a client is idle for N seconds (0 to disable)
timeout 0

# TCP keepalive.
#
# If non-zero, use SO_KEEPALIVE to send TCP ACKs to clients in absence
# of communication. This is useful for two reasons:
#
# 1) Detect dead peers.
# 2) Take the connection alive from the point of view of network
#    equipment in the middle.
#
# On Linux, the specified value (in seconds) is the period used to send ACKs.
# Note that to close the connection the double of the time set here is used
# (by default the kernel will use 2*tcp_keepalive_time).
tcp-keepalive 300

################################# GENERAL #####################################

# By default Godis does not run as a daemon. Use 'yes' if you need it.
daemonize no

# If you run Godis from upstart or systemd, Godis can interact with your
# supervision tree. Options:
#   supervised no      - no supervision interaction
#   supervised upstart - signal upstart by putting Godis into SIGSTOP mode
#   supervised systemd - signal systemd by writing READY=1 to $NOTIFY_SOCKET
#   supervised auto    - detect upstart or systemd method based on
#                        UPSTART_JOB or NOTIFY_SOCKET environment variables
# Note: these supervision methods only signal "process is ready."
#       They do not enable continuous liveness pings back to your supervisor.
supervised no

# If a pid file is specified, Godis writes it where specified at startup
# and removes it at exit.
pidfile /var/run/godis.pid

# Specify the server verbosity level.
# This can be one of:
# debug (a lot of information, useful for development/testing)
# verbose (many rarely useful info, but not a mess like the debug level)
# notice (moderately verbose, what you want in production probably)
# warning (only very important / critical messages are logged)
loglevel notice

# Specify the log file name. Also the empty string can be used to force
# Godis to log on the standard output.
logfile ""

# Set the number of databases. The default database is DB 0.
databases 16

################################ SNAPSHOTTING  ################################

# Save the DB on disk:
#
#   save <seconds> <changes>
#
#   Will save the DB if both the given number of seconds and the given
#   number of write operations against the DB occurred.
#
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed

save 900 1
save 300 10
save 60 10000

# By default Godis will stop accepting writes if RDB snapshots are enabled
# and the latest background save failed.
stop-writes-on-bgsave-error yes

# Compress string objects using LZF when dump .rdb databases?
rdbcompression yes

# Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
rdbchecksum yes

# The filename where to dump the DB
dbfilename dump.rdb

# The working directory.
dir ./

################################# REPLICATION #################################

# Master-Replica replication. Use replicaof to make a Godis instance a copy of
# another Godis server.
# replicaof <masterip> <masterport>

# When a replica loses its connection with the master, or when the replication
# is still in progress, the replica can act in two different ways:
#
# 1) if replica-serve-stale-data is set to 'yes' (the default) the replica will
#    still reply to client requests.
# 2) if replica-serve-stale-data is set to 'no' the replica will reply with
#    an error "SYNC with master in progress" to all commands except:
#    INFO, REPLICAOF, AUTH, PING, SHUTDOWN, REPLCONF, ROLE, CONFIG,
#    SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE, PUBLISH,
#    PUBSUB, COMMAND, POST, HOST: and LATENCY.
replica-serve-stale-data yes

# You can configure a replica instance to accept writes or not. Writing against
# a replica instance may be useful to store some ephemeral data (because data
# written on a replica will be easily deleted after resync with the master) but
# may also cause problems if clients are writing to it because of a
# misconfiguration.
replica-read-only yes

# Replication SYNC strategy: disk or socket.
repl-diskless-sync no

# When diskless replication is enabled, it is possible to configure the delay
# for starting the transfer.
repl-diskless-sync-delay 5

# Replicates execute commands in the background. This can improve throughput
# but risks data loss if the replica crashes before write-back.
repl-disable-tcp-nodelay no

################################## SECURITY ###################################

# Require clients to issue AUTH <PASSWORD> before processing any other
# commands.
# requirepass foobazr

# Command renaming (DEPRECATED).
# rename-command CONFIG ""

################################### CLIENTS ####################################

# Set the max number of connected clients at the same time. By default
# this limit is set to 10000 clients.
maxclients 10000

############################## MEMORY MANAGEMENT ################################

# Set a memory usage limit to the specified amount of bytes.
# maxmemory <bytes>

# MAXMEMORY POLICY: how Godis will select what to remove when maxmemory
# is reached.
#
#    volatile-lru: Evict using approximated LRU among the keys with an expire set.
#    allkeys-lru: Evict any key using approximated LRU.
#    volatile-lfu: Evict using approximated LFU among the keys with an expire set.
#    allkeys-lfu: Evict any key using approximated LFU.
#    volatile-random: Remove a random key among the ones with an expire set.
#    allkeys-random: Remove a random key, any key.
#    volatile-ttl: Remove the key with the nearest expire time (minor TTL)
#    noeviction: Don't evict anything, just return an error on write operations.

maxmemory-policy noeviction

# LRU, LFU and minimal TTL algorithms are not precise algorithms but approximated
# algorithms (in order to save memory), so you can tune it for speed or
# accuracy. By default Godis will check five keys and pick the one that was
# used less recently.
maxmemory-samples 5

############################## LAZY FREEING ####################################

# Redis has two primitives to delete keys. One is called DEL and is a blocking
# deletion of the object. It means that the server stops processing new commands
# in order to reclaim all the memory associated with an object in a synchronous
# way. If the key deleted is associated with a small object, the time needed
# in order to execute the DEL command is very small and comparable to most other
# O(1) or O(log_N) small operations in Redis. However if the key is associated
# with an aggregated value containing millions of elements, the server can
# block for a long time (even seconds) in order to complete the operation.
#
# For the above reasons Redis also offers non blocking deletion primitives
# such as UNLINK (non blocking DEL) and the ASYNC option of FLUSHALL and
# FLUSHDB commands, in order to reclaim memory in background.

lazyfree-lazy-eviction no
lazyfree-lazy-expire no
lazyfree-lazy-server-del no
replica-lazy-flush no

################################ APPEND ONLY MODE ###############################

# By default Godis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but issues can arise when the power is
# lost or Godis crashes.
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Godis can lose just one second of write
# operations in a dramatic event like server power failure, or OS error,
# but the AOF is usually configured with fsync every second, so in this
# mode the theoretical worst case is losing one second of writes.
#
# AOF and RDB persistence can be enabled at the same time.
#
appendonly no

# The name of the append only file (default: "appendonly.aof")
appendfilename "appendonly.aof"

# The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer.
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the AOF. Very safe, very slow.
# everysec: fsync only one time every second. Compromise.
#
# The default is "everysec", as that's usually the right compromise between
# speed and data safety.
appendfsync everysec

# When the AOF fsync policy is set to always or everysec, and a background
# saving process (a background save or AOF log background rewriting) is
# performing a lot of I/O against the disk, in some Linux configurations
# Redis may block too long on the fsync() call. Note that there is no fix for
# this currently, as even performing fsync in a different thread will block
# our synchronous write(2) call.
#
# In order to mitigate this problem it's possible to use the following option
# that will prevent fsync() from being called in the main process while a
# BGSAVE or BGREWRITEAOF is in progress.
#
no-appendfsync-on-rewrite no

# Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file (implicitly calling
# BGREWRITEAOF) when the AOF log size grows by a specified percentage.
#
# This is how it works: Redis remembers the size of the AOF file after the
# latest rewrite (if no rewrite happened since the restart, the size of
# the AOF at startup is used).
#
# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size for the AOF file to be rewritten, this
# is useful to avoid rewriting the AOF file even if the percentage is reached
# but it is still too small.
#
# Specify a percentage of zero in order to disable the automatic AOF
# rewrite feature.

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# An AOF file may be found to be truncated at the end during the Redis
# startup process, when the AOF data gets loaded back into memory.
# This can happen when the system where Redis is running
# crashes, especially when an ext4 filesystem is mounted without the
# data=ordered option.
#
# Redis can either exit with an error when this happens, or load as much
# data as possible (the default) and start if the AOF file is found
# to be truncated at the end.
aof-load-truncated yes

################################ LUA SCRIPTING  ###############################

# Max execution time of a Lua script in milliseconds.
#
# If the maximum execution time is reached Redis will log that a script is
# still in execution after the maximum allowed time and will start to
# reply to queries with an error.
#
# When a script is approaching the maximum execution time the following
# actions are taken:
# 1. Redis logs that a script is running for a long time.
# 2. Redis starts accepting commands again from clients.
#
# The default is 5 minutes. It is possible to set a limit of 0 (no maximum
# execution time, not recommended).
lua-time-limit 5000

################################ REDIS CLUSTER  ###############################

# Normal Redis instances can't be part of a Redis Cluster; only nodes that are
# started as cluster nodes, that is, nodes that have the cluster enabled
# and that have the initial cluster configuration set, can be part of a
# Redis Cluster.
#
# cluster-enabled yes

# Every cluster node has a cluster configuration file. This file is not
# intended to be edited by hand. It is created and updated by Redis Cluster
# nodes. Every Redis Cluster node requires a different cluster configuration
# file. Make sure that instances running in the same system do not have
# overlapping cluster configuration file names.
#
# cluster-config-file nodes-6379.conf

# Cluster node timeout is the amount of milliseconds a node must be unreachable
# for it to be considered in failure state.
#
# Most other internal time limits are a multiple of the node timeout.
#
# cluster-node-timeout 15000

# A replica of a failing master will avoid to start a failover if its data
# looks to be too old.
#
# There is no clear way to check "too old", so the following check is performed:
#
# 1) If there are multiple replicas able to failover, they exchange messages
#    in order to try to give an advantage to the replica with the best
#    replication offset (more data from the master processed).
#    Replicas will try to get their rank by offset, and apply to the start
#    of the failover a delay proportional to their rank.
#
# 2) Every single replica computes the time of the last interaction with
#    its master. This is the last time the replica received a ping from the
#    master, or the last time the replica acknowledged the ping sent to the
#    master (if the master is down, replicas are pinged periodically).
#    If the last interaction is too old in the view of the replica, it will
#    not try to failover at all.
#
# The "replica-validity-factor" is used to adjust the condition.
#
# cluster-replica-validity-factor 10

# Cluster replicas are able to migrate to orphaned masters, that are masters
# that are no longer covered by any replica.
# In order to migrate a replica must be in a "fresh" state, that is,
# it must be a replica of a master that is serving a non-zero number of
# slots, with a replication offset not too old, pinged recently by the master,
# and with no failing migration in progress.
#
# cluster-migration-barrier 1

# By default cluster replicas stop accepting queries if they realize they
# are unable to reach the majority of masters for some time, to increase
# the chance of avoiding data inconsistency in edge cases.
# However there are cases where a subset of the masters may be permanently
# not reachable because of network partitions or other failure modes.
# In such cases continuing to accept queries can help to serve read queries
# despite the fact that the cluster cannot properly failover.
#
# cluster-require-full-coverage yes

# This option, when set to yes, prevents replicas from trying to failover its
# master during master failures. However the master can still manually perform
# a failover when required.
#
# Forced failovers may still be performed, by using the FORCE flag.
#
# cluster-replica-no-failover no

################################## SLOW LOG ###################################

# The Redis Slow Log is a system to log queries that exceeded a specified
# execution time. The execution time does not include I/O operations
# like talking with connected clients, sending the replies and so forth,
# but just the time needed to actually execute the command.
#
# You can configure the slow log with two parameters: one tells Redis
# what is the execution time, in microseconds, to exceed in order for the
# command to get logged, and the other parameter is the length of the
# slow log. When a new command is logged the oldest one is removed from the
# queue of logged commands.

slowlog-log-slower-than 10000
slowlog-max-len 128

################################ LATENCY MONITOR ##############################

# The Redis latency monitoring subsystem samples different operations
# at runtime in order to collect data related to possible sources of
# latency of a Redis instance.
#
# Via the LATENCY command this information is available to the user, that can
# print graphs and obtain reports.
#
# The system only logs operations that were performed in a time equal or
# greater than the amount of milliseconds specified via the
# latency-monitor-threshold configuration directive. When its value is set
# to zero, the latency monitor is turned off.
#
# By default latency monitoring is disabled since it is mostly not needed
# if you don't have latency issues, and collecting data has a performance
# impact, that while small, can be measured under certain conditions.
# Latency monitoring can be enabled at runtime using the command
# CONFIG SET latency-monitor-threshold <milliseconds>. The feature
# is enabled by setting a value different than zero.

latency-monitor-threshold 0

############################### EVENT NOTIFICATION #############################

# Redis can notify Pub/Sub clients about events happening in the key space.
# This feature is documented at https://redis.io/topics/notifications
#
# For instance if keyspace notifications are enabled, and a client performs
# a DEL operation on key "foo" stored in the Database 0, two messages will
# be published via Pub/Sub:
#
# PUBLISH __keyspace@0__:foo del
# PUBLISH __keyevent@0__:del foo
#
# It is possible to select the events that Redis will notify among a set
# of classes. Every class is identified by a single character:
#
#  K     Keyspace events, published with __keyspace@<db>__ prefix.
#  E     Keyevent events, published with __keyevent@<db>__ prefix.
#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...
#  $     String commands
#  l     List commands
#  s     Set commands
#  h     Hash commands
#  z     Sorted set commands
#  x     Expired events (events generated every time a key expires)
#  e     Evicted events (events generated when a key is evicted for maxmemory)
#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.
#
#  The "notify-keyspace-events" takes as argument a string that is composed
#  of zero or multiple characters. The empty string means that notifications
#  are disabled at all.
#
#  Example: to enable list and generic events, from the point of view of the
#           event name, use:
#
#  notify-keyspace-events Elg
#
#  Example 2: to get the stream of the expired keys, use:
#
#  notify-keyspace-events Ex
#
#  By default all notifications are disabled because this feature uses some
#  CPU and the majority of Redis users don't use this feature.

notify-keyspace-events ""

############################### ADVANCED CONFIG ###############################

# Hashes are encoded using a memory efficient data structure when they have a
# small number of entries, and the biggest entry does not exceed a given
# threshold. The thresholds are:
#
# hash-max-ziplist-entries 512
# hash-max-ziplist-value 64
hash-max-ziplist-entries 512
hash-max-ziplist-value 64

# Lists are also encoded in a special way to save a lot of space.
# The special representation is only used when you are under the following
# limits:
#
# list-max-ziplist-size -2
# list-compress-depth 0
list-max-ziplist-size -2
list-compress-depth 0

# Sets have a special encoding in just one case: when a set is composed
# of just strings that happen to be integers in radix 10 in the range
# of 64 bit signed integers.
# The following configuration setting sets the limit in the size of the
# set in order to use this special memory saving encoding.
#
# set-max-intset-entries 512
set-max-intset-entries 512

# Similarly to hashes and lists, sorted sets are also specially encoded in
# order to save a lot of space. This encoding is only used when the length and
# elements of a sorted set are below the following limits:
#
# zset-max-ziplist-entries 128
# zset-max-ziplist-value 64
zset-max-ziplist-entries 128
zset-max-ziplist-value 64

# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
# order to help rehashing the main Redis hash table (the one mapping top-level
# keys to values). The hash table implementation Redis uses (see dict.c)
# performs a lazy rehashing: the more operations you run into a hash table
# that is rehashing, the more rehashing "steps" are performed, so that if the
# server is idle the rehashing is never complete and some more memory is used
# by the hash table.
#
# The default is to use this millisecond 10 times every second in order to
# actively rehash the main dictionaries, freeing memory when possible.
#
# If unsure:
# use "activerehashing yes" if you have a latency sensitive application
# and Redis can't have too many keys, use "activerehashing no" if you have
# latency problems and a huge amount of keys in the hash tables.
activerehashing yes

# The client output buffer limits can be used to force disconnection of clients
# that are not reading data from the server fast enough for some reason (a
# common reason is that a Pub/Sub client can't consume messages as fast as the
# publisher can produce them).
#
# The limit can be set in different ways:
# client-output-buffer-limit <class> <hard limit> <soft limit> <soft seconds>
#
# A client is immediately disconnected if the hard limit is reached, or if
# the soft limit is reached and remains reached for the specified number of
# seconds (default: 0).
#
# Different classes can have different limits:
#
# normal -> normal clients including MONITOR clients
# replica -> replica clients
# pubsub -> clients subscribed to at least one pubsub channel or pattern
#
# The default limits for all classes are:
#
# client-output-buffer-limit normal 0 0 0
# client-output-buffer-limit replica 256mb 64mb 60
# client-output-buffer-limit pubsub 32mb 8mb 60

client-output-buffer-limit normal 0 0 0
client-output-buffer-limit replica 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60

# Redis calls an internal function to perform many background tasks, like
# closing connections of clients in timeout, purging expired keys, etc.
#
# Not all tasks are performed with the same frequency, but Redis checks for
# tasks to perform according to the specified "hz" value.
#
# By default "hz" is set to 10. Raising the value will use more CPU when
# Redis is idle, but at the same time will make Redis more responsive when
# there are many keys expiring at the same time, and keys may be expired
# more often.
#
# The range is between 1 and 500, however a value over 100 is usually not
# a good idea. Most users should use the default of 10 and raise this up to
# 100 only in environments where very low latency is required.
hz 10

# Normally it is useful to have an HZ value which is a multiple of 10 in order
# to synchronize with the Redis timeslice and other system time functions.
#
# Enable dynamic HZ to adjust the HZ value based on the number of connected
# clients. Redis will use more HZ when there are many connected clients.
#
dynamic-hz yes

# When a child rewrites the AOF file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
aof-rewrite-incremental-fsync yes

# When Godis saves RDB file, if the following option is enabled
# the file will be fsync-ed every 32 MB of data generated. This is useful
# in order to commit the file to the disk more incrementally and avoid
# big latency spikes.
rdb-save-incremental-fsync yes
